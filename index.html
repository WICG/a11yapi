<!DOCTYPE html>
<html>
  <head>
    <title>
      Accessibility API
    </title>
    <meta charset='utf-8'>
    <script src='https://www.w3.org/Tools/respec/respec-w3c-common' async
    class='remove'>
    </script>
    <script class='remove'>
    /*Make tidy happy*/
    var respecConfig = {
          // specification status (e.g. WD, LCWD, WG-NOTE, etc.). If in doubt use ED.
          specStatus:           "unofficial",
          // the specification's short name, as in http://www.w3.org/TR/short-name/
          shortName:            "a11y-api",

          // if your specification has a subtitle that goes below the main
          // formal title, define it here
          // subtitle   :  "an excellent document",

          // if you wish the publication date to be other than the last modification, set this
          // publishDate:  "2009-08-06",

          // if the specification's copyright date is a range of years, specify
          // the start date here:
          // copyrightStart: "2005"

          // if there is a previously published draft, uncomment this and set its YYYY-MM-DD date
          // and its maturity status
          // previousPublishDate:  "1977-03-15",
          // previousMaturity:  "WD",

          // if there a publicly available Editor's Draft, this is the link
          // edDraftURI:           "http://berjon.com/",

          // if this is a LCWD, uncomment and set the end of its review period
          // lcEnd: "2009-08-05",

          // editors, add as many as you like
          // only "name" is required
          editors:  [
              {
                  name:       "Alexander Surkov"
              ,   url:        "http://mozilla.org/"
              ,   mailto:     "you@example.org"
              ,   company:    "mozilla"
              ,   companyURL: "http://mozilla.com/"
              },
          ],
          // name of the WG
    //         wg:           "None",

          // URI of the public WG page
    //         wgURI:        "http://example.org/really-cool-wg",

          // name (without the @w3c.org) of the public mailing to which comments are due
    //          wgPublicList: "spec-writers-anonymous",

          // URI of the patent status for this WG, for Rec-track documents
          // !!!! IMPORTANT !!!!
          // This is important for Rec-track documents, do not copy a patent URI from a random
          // document unless you know what you're doing. If in doubt ask your friendly neighbourhood
          // Team Contact.
    //        wgPatentURI:  "",
          // !!!! IMPORTANT !!!! MAKE THE ABOVE BLINK IN YOUR HEAD
      };
    </script>
  </head>
  <body>
    <section id='abstract'>
      <p>
        There's number of objectives on the web to improve accessibility and
        usability support. Web applications want to provide special support for
        their users, helping them navigate and perceive the content. The
        browser has a number of add-ons serving to improve accessibility
        support, for example, the app letting to navigate landmarks on the web
        page. These tasks require accessibility API similar to what desktop
        assistive technologies have.
      </p>
      <p>
        Web accessibility API also allows for in-browser automated
        accessibility testing of web content, i.e. helpful for checking that
        HTML and other standards in the browser are accessible to all users.
      </p>
      <p>
        On the other hand there's a growing need for making graphical content
        accessible. These are charts, graphs and other various visual forms
        that are drawn using HTML canvas or SVG. There's also a tendency to use
        HTML canvas element in place of DOM because of performance matter,
        here's an example. All markup in the example is defined in JavaScript
        and there is a need for a non-DOM accessibility solution to make the
        content accessible.
      </p>
    </section>
    <section id='sotd'>
      <p>
        This is a work in progress.
      </p>
      <section>
        <h3>
          Things we want feedback on!
        </h3>
        <ul>
          <li>Should we specify hasAnyOf() and hasAllOf() for StateSet and
          AttributeMap? Or should we just rely on JS's Array interface to do
          the same thing? Pros:... Cons:....
          </li>
          <li>Is it ok to use the term "attributes" for accessible attributes
          in this spec? or will it cause confusion with DOM attributes?
          (suggestion is to maybe rename "properties" if it's going to be
          confusing)
          </li>
        </ul>
      </section>
    </section>
    <section>
      <h2>
        Accessibility API
      </h2>
      <p>
        The API provides bunch of interfaces that are used to express the
        semantics of web content in a way that assistive technologies (AT)
        knows how to deal with. Also it provides ability to search and traverse
        the content and interact with it. It has a way to extend existing
        semantics of the markup, and add new semantics for inaccessible content
        like drawings made using the <code>canvas</code> element. Each piece of
        semantic content has an associated accessible element the AT operates
        on.
      </p>
      <section>
        <h3>
          Terms
        </h3>
        <p>
          An <dfn>assistive technology</dfn> or <dfn>AT</dfn> is software that
          provides an improved user experience for different users types
          including people with disabilities. It can be in the form of a native
          application, or web application (e.g., zoom tool), or service (e.g.,
          speech-to-text).
        </p>
        <p>
          A <dfn>content entity</dfn> is semantically isolated piece of
          content. For example, <a>interactive content</a> in [[!HTML]].
        </p>
        <p>
          An <dfn>accessible element</dfn> is an object expressing the
          semantics of a <a>content entity</a>. The object is represented by
          the <code>AccessibleElement</code> interface.
        </p>
        <p>
          A <dfn>role</dfn> of an <a>accessible element</a> identifies the
          function of the accessible element to assistive technology (e.g.,
          such as "button", "textbox", etc. See also [[!WAI-ARIA]] roles).
        </p>
        <p>
          A <dfn>name</dfn> of an <a>accessible element</a> is a primary human
          readable property of an accessible element. For example, <a>assistive
          technology</a> could present the name of the <a>accessible
          element</a> to the user.
        </p>
        <p>
          A <dfn>description</dfn> of an <a>accessible element</a> is secondary
          human readable property of an <a>accessible element</a>. It's used to
          describe and provide more detailed information than <a>name</a> to
          the user about <a>content entity</a>, the accessible element was
          created for (e.g., a tool tip).
        </p>
        <p>
          A <dfn>value</dfn> of an <a>accessible element</a> is text property
          of an <a>accessible element</a> created for a control element. It
          identifies additional information about the control, such as position
          on a slider or text in an edit field.
        </p>
        <p>
          An <a>accessible element</a> has a set of <dfn>accessible
          states</dfn>, which is represented by objects that implement the
          <code>StateSet</code> interface. Conceptually, each one of these
          <dfn>states</dfn> is a boolean that represents the state the content
          entity is currently in. For example, if a [[!HTML]]
          <code>button</code> element is in the focused state (e.g., the user
          has focused the button by tabbing to it), then its accessible element
          will have "<code>focused</code>" state in its <a>accessible
          states</a>.
        </p>
        <p>
          An <dfn>attribute</dfn> of an <a>accessible element</a> is property
          that provides extra information about its <a>content entity</a>.
          Attributes are represented by objects that implement the
          <code>AttributeMap</code> interface. For example, autocomplete
          feature on an <code>input</code> element would map to
          <code>autocomplete</code> attribute with possible values
          <code>inline</code>, <code>list</code>, or <code>both</code>.
        </p>
        <p>
          A <dfn>pattern</dfn> of an <a>accessible element</a> expresses the
          associated semantics of the <a>content entity</a> that is not
          expressed by means of <code>AccessibleElement</code> interface.
        </p>
        <p>
          A <a>accessible element</a> can have one or more <dfn>relations</dfn>
          to other accessible elements. Each relation has a <dfn>relation
          type</dfn> that expresses its semantics. Relations of an accessible
          objects are represented by objects that implement the
          <code>RelationMap</code> interface.
        </p>
        <p>
          An <dfn>action</dfn> of an <a>accessible element</a> is an action
          supported by the <a>content entity</a>. An action can be performed on
          a content entity by the user (e.g., a button click). Accessible
          actions are represented by objects that implement the
          <code>ActionMap</code> interface.
        </p>
        <p>
          An <dfn>interaction</dfn> is device dependent interaction, such as
          keyboard shortcut or mouse gesture used to invoke the <a>action</a>.
          Interactions on an <a>accessible element</a> are represented by
          objects that implement the <code>InteractionMap</code> interface.
        </p>
        <p>
          An <dfn>accessible tree</dfn> is a tree of <a title=
          "accessible element">accessible elements</a> associated to each other
          by a parent-child relationship.
        </p>
        <p>
          An <dfn>accessible parent</dfn> of the referred <a>accessible
          object</a> is its parent in the <a>accessible tree</a>.
        </p>
        <p>
          An <dfn>accessible child</dfn> of the referred <a>accessible
          object</a> are its child accessible elements in the <a>accessible
          tree</a>. It is represented by the <code>AccessibleChildren</code>
          interface.
        </p>
        <p>
          An <dfn>accessible DOM node</dfn> or <dfn>accessible DOM
          element</dfn> is a [[!DOM]] <code>Node</code> or <code>Element</code>
          that has an associated <a>accessible element</a>.
        </p>
        <p>
          An <dfn>accessible position</dfn> is a point in the content if it's
          presented in one-dimensional way, that can be entirely and
          sequentially traversed with a minimal step of a semantic change. For
          example, a position can be placed at a control element or in text of
          a paragraph. User focus can be described by <a>accessible
          position</a>.
        </p>
        <p>
          An <dfn>accessible pin</dfn> is an object representing <a>accessible
          position</a> and implementing <code>AccessiblePin</code> interface.
        </p>
      </section>
      <section class="informative">
        <h3>
          Understanding the terms
        </h3>
        <p>
          Each <a>content entity</a> has an associated <a>accessible
          object</a>. Each <a>accessible element</a> is described by accessible
          properties like <a>role</a>, <a>name</a>, <a title=
          "relation">relations</a> etc.
        </p>
        <figure>
          <img src="images/props.png" alt="accessible properties diagram">
          <figcaption>
            Accessible properties.
          </figcaption>
        </figure>
        <p>
          <a title="accessible element">accessible element</a> can be related
          to each other by number of different types.
        </p>
        <figure>
          <img src="images/rels.png" alt="accessible relations diagram">
          <figcaption>
            Relations. A color of arrows connecting accessible element
            represent own relation type.
          </figcaption>
        </figure>
        <p>
          All <a title="accessible element">accessible elements</a> are
          organized into <a title="accessible tree">accessible trees</a>, in
          other words all accessible elements are supposed to stay in
          parent-child relationship. The <a>assistive technology</a> can
          traverse the document by traversing its accessible tree.
        </p>
        <figure>
          <img src="images/tree.png" alt="accessible tree">
          <figcaption>
            Accessible tree.
          </figcaption>
        </figure>
        <p>
          The browser exposes semantics of the content to the <a>assistive
          technology</a> like screen readers or screen magnifiers softwares via
          platform APIs like ATK, IAccessible2, UIA, NSAccessibility or this
          one. The assistive technology communicates back to the content by the
          browser via platform APIs.
        </p>
        <figure>
          <img src="images/overview.png" alt="overview diagram">
          <figcaption>
            Overview of the communication between the content and the
            <a>assistive technology</a>.
          </figcaption>
        </figure>
      </section>
    </section>
    <section>
      <h2>
        Extensions to the <code>Node</code> interface
      </h2>
      <p>
        Assistive technology, or the developer, can request an <a>accessible
        object</a> from a [[!DOM]] <code>Node</code> if the <code>Node</code>
        is accessible, i.e. it expresses semantics to the assistive technology.
      </p>
      <pre class="idl">
partial interface Node {
  readonly attribute AccessibleElement? accessibleElement;
};
</pre>
      <section>
        <h3>
          <code>AccessibleElement</code> attribute
        </h3>
        <p>
          The <code>AccessibleElement</code> attribute the user agent MUST
          return the accessible element associated with this <code>Node</code>
          (if any). Otherwise, it returns <code>null</code>.
        </p>
      </section>
    </section>
    <section>
      <h2>
        AccessibleElement interface
      </h2>
      <pre class="idl">
interface AccessibleElement {
  attribute DOMString role;
  attribute DOMString name;
  attribute DOMString description;
  attribute DOMString value;

  readonly attribute StateSet states;

  readonly attribute AttributeMap attributes;

  sequence&lt;DOMString&gt; getPatterns();
  object toPattern(DOMString type);

  readonly attribute RelationMap relations;
  AccessibleElement? relativeOf(DOMString type);

  readonly attribute ActionMap actions;
  void activate(DOMString action);
  readonly attribute InteractionMap interactions;

  readonly attribute AccessibleElement? parent;
  readonly attribute AccessibleChildren children;

  readonly attribute Node? DOMNode;
  attribute AccessibleSource? source;
};
</pre>
      <section>
        <h3>
          <code>role</code> attribute
        </h3>
        <p>
          The <dfn><code>role</code></dfn> attribute represents the accessible
          role that is either developer defined or a role as per [[!WAI-ARIA]]
          (e.g., "button", "menu", "textfield").
        </p>
      </section>
      <section>
        <h3>
          <code>name</code> attribute
        </h3>
        <p>
          The <dfn><code>name</code></dfn> attribute represents ...
        </p>
        <p>
          When setting, ...
        </p>
      </section>
      <section>
        <h3>
          <code>description</code> attribute
        </h3>
        <p>
          The <dfn><code>description</code></dfn> attribute ...
        </p>
        <p>
          When setting, ...
        </p>
      </section>
      <section>
        <h3>
          <code>value</code> attribute
        </h3>
        <p>
          The <dfn><code>value</code></dfn> attribute ...
        </p>
        <p>
          When setting, ...
        </p>
      </section>
      <section>
        <h3>
          <code>states</code> attribute
        </h3>
        <p>
          The <dfn><code>value</code></dfn> attribute represents the accessible
          states...
        </p>
      </section>
      <section>
        <h3>
          <code>attributes</code> attribute
        </h3>
        <p>
          The <dfn><code>attributes</code></dfn> attribute represents ...
        </p>
        <p>
          The accessible element can support a number of attributes to express
          the semantics that cannot be described by base properties of an
          accessible element.
        </p>
        <p>
          Returns a <code>AttributeMap</code> for all object attributes exposed
          on the accessible element. If accessible element attributes are
          changed then the object reflects the actual state of attributes. The
          implementation is not required to pre-compute any of the attributes.
        </p>
        <div class="note">
          <p>
            Set of exposed attributes depends on semantics of the [[!DOM]]
            element. As an example, typical attributes are:
          </p>
          <dl>
            <dt>
              DOMString autocomplete:
            </dt>
            <dd>
              Exposed on text fields. Values are list, none, inline, both.
            </dd>
            <dt>
              DOMString live:
            </dt>
            <dd>
              Points that the accessible is live region. Values are assertive
              and polite.
            </dd>
            <dt>
              DOMString relevant:
            </dt>
            <dd>
              Lists all notifications that qualifies for live region.
            </dd>
          </dl>
        </div>
      </section>
      <section>
        <h3>
          <code>parent</code> attribute
        </h3>
        <p>
          The <dfn><code>parent</code></dfn> attribute represents <a>accessible
          parent</a> of this <a>accessible element</a>.
        </p>
      </section>
      <section>
        <h3>
          <code>children</code> attribute
        </h3>
        <p>
          The <dfn><code>children</code></dfn> attribute represents the child
          accessible elements of this <a>accessible element</a>.
        </p>
        <p>
          Returns <code>AccessibleChildren</code> object containing all child
          <a title="accessible element">accessible elements</a>.
        </p>
      </section>
      <section>
        <h3>
          attribute
        </h3>
      </section>
      <section>
        <h3>
          attribute
        </h3>
      </section>
    </section>
    <section>
      <h2>
        AccessiblePin interface
      </h2>
      <p>
        <code>AccessiblePin</code> serves to traverse the content, for example,
        if you need to navigate a document by headings or navigate a paragraph
        by words. It describes an <a>accessible position</a> in the content.
        The <a>accessible pin</a> can be moved into the given direction within the
        document to the content complying with the given criteria. A movement
        can be illustrated by verbal descriptions like "move the pin forward to
        a next heading" or "move the pin one word back".
      </p>
      <pre class="idl">
[Constructor(AccessibleElement anchor, optional AccessibleElement root)]
interface AccessiblePin {
  AccessiblePin? move(Where where, Criteria criteria);
};

enum Where {
  "forward",
  "backward"
};

callback Criteria = "at "or "next" (AccessibleElement);
</pre>
      <section>
        <h3>
          <code>move</code> method
        </h3>
        <p>
          Moves the <a>accessible pin</a> to a next position in the
          <a>accessible tree</a>.
        </p>
      </section>
    </section>
    <section>
      <h2>
        <code>StateSet</code> interface
      </h2>
      <p>
        live object for all accessible states of an accessible element, i.e. if
        the states of the accessible element changes then the object reflects
        that. Implementation is not required to compute any state until
        requested.
      </p>
      <p class="issue">
        Describe why live?
      </p>
      <pre class="idl">
interface StateSet {
  readonly setlike&lt;DOMString&gt;;
  boolean hasAnyOf(DOMString... states);
  boolean hasAllOf(DOMString... states);
};
</pre>
      <section class="informative">
        <h3>
          Example of usage
        </h3>
        <p>
          Example of a script that logs to console all accessible element
          states.
        </p>
        <pre class="example highlight">
let accEl = document.getElementById("foo").AccessibleElement;
for (let state of accElm.states) {
  console.log(state);
}
</pre>
      </section>
    </section>
    <section>
      <h2>
        <code>AttributeMap</code> interface
      </h2>
      <p>
        The <code>AttributeMap</code> is an interface aimed to work with {name,
        value} pairs of accessible attributes.
      </p>
      <pre class="idl">
interface AttributeMap {
  readonly maplike&lt;DOMString, any&gt;;

  boolean hasAnyOf(Object map); // Needs more work
  boolean hasAllOf(Object map); // Needs more work
};
</pre>
    </section>
    <section>
      <h2>
        Dependencies
      </h2>
      <p>
        The following definitions are in the [[!HTML]] specification:
      </p>
      <ul>
        <li>
          <a href=
          "http://www.w3.org/TR/html5/dom.html#interactive-content"><dfn>interactive
          content</dfn></a>
        </li>
      </ul>
    </section>
    <section>
      <h2>
        <code>AccessibleChildren</code> interface
      </h2>
      <p>
        The <code>AccessibleChildren</code> is an iterable interface aimed to
        work with child accessible elements.
      </p>
      <pre class="idl">
interface AccessibleChildren {
  iterable&lt;AccessibleElement&gt;;
};
</pre>
    </section>
    <section class='appendix'>
      <h2>
        Acknowledgements
      </h2>
      <p>
        Many thanks to Robin Berjon for making our lives so much easier with
        his cool tool.
      </p>
    </section>
  </body>
</html>
